/*
* For the moment, running gradle modAPK followed by gradle APK should yield a modded APK that can be signed then installed.
* There is no automatic signing yet, I sign the APK with my own keystore. Some emulators can run unsigned APKs,
* so if you're running the APK on an emulator (as you should) you can forego the signing for the moment.
* Not a top priority until alpha release maybe?
*
*
* modAPK compiles both chimera and mod java files, decompiles the apk inside saterskog/cell.apk, patches it using patcher.jar in /tools/patcher.jar
* and the patch file in saterskog/patch.chimera, then it uses d8 to convert .class mod and chimera files to classes.dex and finally baksmali to
* obtain smali files which it then inserts into the APK at the correct locations. Not to mention the mods.txt manifest inside the /assets/ folder of the APK.
* There certainly is a more straightfoward way to convert java to smali and I will switch to that later on, but for testing purposes baksmali works well.
*/

plugins {
    id 'java'
}

repositories {
    google()
    mavenCentral()
    maven {
        url 'https://storage.googleapis.com/r8-releases/raw'
    }
}

dependencies {
    configurations.maybeCreate("tools")
    tools "com.android.tools:r8:8.2.55"
    tools "org.apktool:apktool-cli:2.11.1"
}

//=========================================v Global Variables v=========================================
def chimeraSources = fileTree('src/com/saterskog/cell_lab')
        .include('**/*.java')
        .collect { it.absolutePath }
def modSources = fileTree('src/com/saterskog/mods')
        .include('**/*.java')
        .collect { it.absolutePath }
def chimeraDir = file('chimera')
def chimeraJar = file('chimera/api/ChimeraAPI.jar')
def apkURL = "https://cell-lab.net/apks/cell_lab_103.apk"
//=========================================^ Global Variables ^=========================================


tasks.register('buildSourceJar',Exec){
    description 'Packages API into readable source jar for IDE integration'

    mkdir("chimera/api")
    commandLine 'jar','cf','chimera/api/ChimeraSrc.jar','src/com/saterskog/cell_lab'
}

// Task to compile Chimera-specific Java files
tasks.register('compileChimera', Exec) {
    description 'Compiles Chimera Java files into build/chimera directory'

    file('build/chimera').mkdirs()
    // Using --release since android tends to lag behind newer jdks and using jdk 21 makes d8 throw an error due to it being too new.
    commandLine 'javac','--release','17','-d', 'build/chimera', *chimeraSources
}

tasks.register('buildChimera',Exec){
    dependsOn compileChimera
    file('chimera/api').mkdirs()

    commandLine 'jar','cf',chimeraJar,'-C','build/chimera','.'
}

task buildMod(type: Exec) {
    description 'Builds the mod by depending on buildAll'

    file('build/mods').mkdirs()
    commandLine 'javac', '-cp', chimeraJar, '--release', '17','-d', 'build/mods', *modSources
}

task getVanillaAPK (type: Exec){
    description "downloads a vanilla Cell Lab apk from the official website"

    def file = new File("saterskog/cell.apk")
    if(!file.exists()){
        commandLine 'curl',apkURL,'-o','saterskog/cell.apk'
    }
    else{
        commandLine 'echo','apk already present...'
    }

}

// Task to generate DEX file for mod classes Dont mind the debugging.
task getDex(type: Exec) {
    description 'Converts mod class files to DEX format using D8 dependency'
    dependsOn buildMod

    def classDir = file('build/chimera/com/saterskog')
    def outputDir = file('build/dex_output')

    inputs.dir(classDir)
    outputs.dir(outputDir)

    doFirst {
        def d8Jar = configurations.tools.files.find { it.name.contains("r8") }
        if (d8Jar == null) {
            throw new GradleException("D8 JAR not found in dependencies. Make sure R8 is included!")
        }

        def classes = fileTree(classDir).include('**/*.class').collect { it.absolutePath }
        println "Found class files: ${classes ?: 'None'}"

        outputDir.mkdirs()
        fileTree(outputDir).each { it.delete() }

        if (!classes) {
            throw new GradleException("No class files found in ${classDir.absolutePath}")
        }

        commandLine 'java', '-cp', d8Jar, 'com.android.tools.r8.D8', '--output', outputDir, *classes
    }
}

// Task to disassemble DEX into Smali
task getSmali(type: Exec) {
    description 'Disassembles DEX file into Smali code'
    dependsOn getDex

    workingDir file('tools')

    commandLine 'java', '-jar', 'baksmali-2.5.2.jar', 'd',
            '../build/dex_output/classes.dex', '-o', '../build/smali'
}

//I made it work with remote apktool dependency rather than my local installation.
task deAPK(type: Exec){
    mustRunAfter getVanillaAPK
    workingDir file('saterskog')
    mkdir("saterskog/apk")

    def apktoolJar = configurations.tools.find { it.name.contains('apktool-cli') }
    commandLine 'java', '-jar', apktoolJar, 'd', 'cell.apk', '-o', './apk','-f'
}

//This should never be called alone, APK will have runtime errors if ChimeraHooks.smali isn't included inside
//This must run sequentially since patches are supposed to build ontop of the previos file's worth.
task patchAPK {
    doFirst {
        def chimeraFiles = chimeraDir.listFiles({ file -> file.name.endsWith('.chimera') } as FileFilter)

        if (!chimeraFiles) {
            throw new GradleException("No .chimera files found in ${chimeraDir.absolutePath}")
        }

        chimeraFiles.each { chimeraFile ->
            println "Patching: ${chimeraFile.absolutePath}"
            exec {
                workingDir projectDir
                commandLine 'java', '-jar', './tools/patcher.jar', 'saterskog/apk/smali', chimeraFile.absolutePath
            }
        }
    }

    doLast {
        println "All patches applied."
    }
}

// This will find source files (.java) for mods in com/saterskog/mods and add them to mods.txt
// Do note that only classes annotated @ChimeraMod will be loaded as mods.
// There is a hacky workaround maybe using static blocks but that's some nerd shit
//TODO: make a task that can find mod binaries (.jar?), convert to smali and also add them.
//TODO: maybe have gradle inspect jar, retrieve classes, update mods.txt THEN convert to smali and bundle inside APK.
//TODO: that should greatly simplify multi-mod bundling, skipping the compilation entirely for pre-compiled mods.
task findModSources {
    def directory = file('src/com/saterskog/mods')
    def outputFile = file('saterskog/mods.txt')

    doLast {
        outputFile.parentFile.mkdirs()
        outputFile.createNewFile()

        outputFile.text = ""

        directory.eachFileRecurse { file ->
            if (file.name.endsWith('.java')) {
                String fullyQualifiedName = file.path.replace(directory.path + File.separator, '')
                        .replace(File.separator, '.').replace('.java', '')

                outputFile.append('com.saterskog.mods.'+fullyQualifiedName + '\n')
            }
        }
    }
}

//This task should insert the mods.txt file inside apk/assets/ where it is expected to be.
task insertModManifest(type: Copy) {
    from 'saterskog/mods.txt'
    into 'saterskog/apk/assets'
    doLast {
        if (!file('saterskog/mods.txt').exists()) {
            throw new GradleException("Could not fetch mod manifest file!")
        }
        if (!file('saterskog/apk/assets').exists()) {
            throw new GradleException("Assets folder does not exist. Make sure to decompile the apk correctly!")
        }
        println "Mod manifest successfully copied into assets folder"
    }
}

task insertModFiles(type: Copy) {
    from 'build/smali/com/saterskog/mods'
    into 'saterskog/apk/smali/com/saterskog/mods'

    doFirst {
        def sourceDir = file('build/smali/com/saterskog/mods')
        if (!sourceDir.exists()) {
            throw new GradleException("Could not fetch mod smali files!")
        }
    }

    doLast {
        def destinationDir = file('saterskog/apk/smali/com/saterskog/mods')
        if (!destinationDir.exists()) {
            destinationDir.mkdirs()
            println "Created mods directory"
        }
        println "Mod files successfully bundled in APK"
    }
}

task insertChimeraHooks(type: Copy) {
    from 'build/smali/com/saterskog/cell_lab'
    into 'saterskog/apk/smali/com/saterskog/cell_lab'

    doFirst {
        def sourceDir = file('build/smali/com/saterskog/cell_lab')
        if (!sourceDir.exists()) {
            throw new GradleException("Could not fetch Chimera smali files!")
        }
    }

    doLast {
        def destinationDir = file('saterskog/apk/smali/com/saterskog/cell_lab')
        if (!destinationDir.exists()) {
            destinationDir.mkdirs()
            println "Inserted Chimera core files"
        }
        println "Chimera core files successfully bundled in APK"
    }
}

task modAPK{
    dependsOn getVanillaAPK,deAPK,patchAPK,getSmali,findModSources,insertModManifest,insertChimeraHooks,insertModFiles
}

task APK(type: Exec){
    mustRunAfter modAPK
    mkdir("build/apk/signed")
    commandLine 'apktool','b','saterskog/apk','-o','build/apk/mod.apk'

    def apktoolJar = configurations.tools.find { it.name.contains('apktool-cli') }
    commandLine 'java', '-jar', apktoolJar, 'b', 'saterskog/apk', '-o', 'build/apk/mod.apk','-f'
}


// Task to clean the build directory
task cleanBuild(type: Delete) {
    description 'Deletes the build directory'
    delete 'build'
}

task cleanAPK(type: Delete) {
    description 'Cleans the apk decompilation directories'
    delete 'saterskog/apk'
}

task debugJavac(type: Exec) {
    commandLine 'javac', '-version'
}

//========================================v Gradle Task Aliases v========================================
tasks.register('bsjar'){dependsOn buildSourceJar}

tasks.register('bc'){dependsOn buildChimera}
tasks.register('bm'){dependsOn buildMod}

//Pretty much does everything
tasks.register('apk'){dependsOn modAPK,APK}
//========================================^ Gradle Task Aliases ^========================================
